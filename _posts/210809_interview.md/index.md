---
title: 개발자 인터뷰 가이드
date: 2021-08-09 23:13:33
tags: [취업]
---

## 개발자 인터뷰 가이드

---

### 채용

#### 고전적인 채용 절차

고전적인 채용 절차는 `[채용공고] - [서류전형] - [면접] - [임원 면접]`의 과정을 거친다.

고전적인 채용 절차의 문제

> - 이력서 내용의 사실 여부 판단이 어렵다.
> - 지원자의 코딩 실력을 알기 어렵다.
> - 지원자가 많으면 너무 많은 서류를 검토해야 한다.
> - 지원자당 긴 시간을 면접하게 되면 시간이 너무 많이 소비된다.
> - 서술형 질문에 대한 답변을 암기해서 올 수 있다.
> - 여전히 코딩 실력은 판단하기 힘들다.
> - 비용이 발생한다.
> - 지원자 성격에 따라 평소 실력을 발휘하지 못할 수 있다.

### 코딩 인터뷰

> 일반적인 환경에서 코딩 -> 손코딩 -> 입으로 설명하면서 코딩 순으로 연습한다.  
> 개발환경에서도 못하는 코딩이 갑자기 손으로 써지지는 않는다. 인터뷰에서 설명을 해야하기 때문에 입으로 설명하는 연습도 빼먹으면 안된다.  
> 문제를 보고 다짜고짜 문제부터 푸는게 아닌 문제에 대한 정의를 내리고 어떤 절차로 진행할지 설명한 후 문제를 푸는것이 좋다. 문제를 푸는 중 해결이 되지 않을 때 면접관이 힌트를 제공한다면 그 힌트를 이용해서 어떻게 적용시킬지 대답해주어야 한다.

#### 코딩 인터뷰 프레임워크

문제를 해결함에 있어 면접관과 인터뷰를 한다는 느낌보다는 동료와 같이 해결한다는 관점으로 접근해야하고 문제를 푸는 주체가 본인이라고 생각해야한다. 중요한건 동료이기 때문에 같이 풀어나간다고 접근해야한다.

1. 가장 먼저 해당 문제를 정리하고 본인이 이해한것이 맞는지 면접관에게 확인한다.
2. 입력, 출력 범위, 타입같은것 등 문제에서 명확하지 않은것을 체크한다.
3. 위에 내용들을 실제 예를 들어가며 다시 한번 체크한다.
4. 이제 문제에 대한 고민을 하고 어떤 방식으로 구현할지 결정한다.
5. 해당 로직을 설명하고 `해당 시간과 공간 알고리즘 복잡도`를 설명
6. 로직대로 코드를 작성한다.
7. 3번에 예시를 케이스로 테스트한다.

#### 알고리즘 복잡도

빅 오 노테이션: O(n), O(logN), O(1), O(n제곱)

- 함수에서 엄밀한 점근적 상한을 나타내는 표기법
- 수자는 다 빼고 가장 증가율이 높은 수식만 남긴다.
- f(n) = 4 O(1)
- f(n) = 3n + 3n + 3 O(n)
- f(n) = 8n제곱 + n + 3 O(n제곱)
- f(n) = 8n + log(n) +3 O(n)
- O(1)은 여러개의 매개변수가 들어와도 리턴값이 고정되는걸 의미한다.
- O(n)은 매개변수가 들어오는거에 비례하는 리턴값을 의미한다.
- O(n제곱)은 주로 2중 포문같은것을 의미하는데 면접관은 이런 코드를 바라지 않을 확률이 높으므로 이런방식으로 답을 구하려 한다면 다시 생가해보는것이 좋다.
- 매개변수가 배열인 함수에서 리턴값이 고정된 인덱스 값을 호출한다면 이건 시간복잡도가 O(1)이고 메모리에 변화가 없기 때문에 공간복잡도도 (1)이다.
- 숫자 배열이 들어와 합을 구하는 함수라면 같은 반복문을 계속하기 때문에 시간 복잡도는 O(n)이고 더하면서 하나의 변수에만 값을 저장하기 때문에 공간복잡도는 O(1)이다.
- 재귀함수의 경우 반복문이 없어도 계속 본인을 호출하기 때문에 시간복잡도가 O(n)이고 재귀함수는 스택영역을 사용하기 때문에 메모리를 계속 사용하여 공간복잡도 또한 O(n)이다.
- 숫자 배열에서 특정 숫자를 찾기위해 보통 바이너리 서치를 사용하는데 이는 가운데 인덱스를 가져와 특정값과 비교하고 작다면 -1을 크다면 +1을 하여 총 인덱스에 절반씩 버려가며 찾을 수 있다. 이런 바이너리 서치의 경우 절반씩 날라가기 때문에 시간 복잡도가 O(logN)이다. 공간 복잡도의 경우 들어오는 값에 상관없이 저장용 변수만 선언되므로 O(1)이다.

간단한 예제

> 매개변수를 인트형 List로 받는데 해당 리스트에는 같은 숫자가 2개씩 있는데 오직 하나의 숫자만 한개가 있다. 하나만 있는 숫자를 리턴한다.  
> 기본적으로 매개변수를 반복시키기 때문에 n이 존재하고 또 새로생성한 리스트에 해당 데이터가 있는지 검사하면서 반복을 하기때문에 n이 존대한다. 그래서 시간복잡도는 O(n제곱)이다.  
> 공간 복잡도의 경우에도 해당 매개변수 리스트에 같은 숫자들이 연속으로 나온 전제가 없으므로 한번에 몇개까지 리스트에 데이터가 들어갈지 모르므로 O(n)이다.  
> 하나의 리스트를 선언하고 매개변수로 넘어온 리스트를 반복하면서 새로 생성한 리스트에 반복문으 숫자가 들어있다면 제거하고 없다면 숫자를 추가해준다. 이렇게 반복하다보면 같은숫자들은 같은숫자가 나올경우 제거되기 때문에 하나만 있는 숫자만 리스트에 남게된다.
> 만약 같은 문제를 맵으로 한다면 맵의 키를 해당 리스트이 숫자로, 맵에서 해당 키가 있다면 값을 불러와 +1해주어 해당 숫자의 카운트를 값으로 넣어준다.  
> 이럴경우 시간복잡도는 리스트와는 다르게 맵은 반복하는 형태가 아니므로 O(n)의 방식이고 공간복잡도는 여전히 매개변수에 따라 맵의 크기가 변하므로 O(n)이다.  
> 마지막으로 xor를 활용하는 방법이 있다. xor같은 경우 같은 숫자라면 0으로 0과 다른숫자라면 원래대로 보여준다. 그렇기 때문에 하나의 변수만 선언해서 작업을 완료할 수 있다. 반복문을 사용하기 때문에 시간복잡도는 여전히 O(n)이지만 공간복잡도의 경우 O(1)이다.

#### 배열

배열은 연속된 메모리 영역에 저장된 데이터로 조회가 O(1), 추가 및 삭제가 O(n)의 복잡도를 가지고 있다. 조회는 빠르고 추가 및 삭제는 느리다.

- 자바에서 배열은 만들 때 크기를 정해야 하며, 추가 및 삭제 기능은 없다.
- 다른 자료구조를 구현하는데 사용하는 가장 기본적인 데이터 구조다.

배열문제는 우선 정렬이 되어있는지 체크한다.  
인트형 배열에서 같은 숫자가 하나라도 있다면 true를 리턴해주는 문제가 출제되었을때 i,j로 2중포문으로 해결한다면 시간복잡도는 O(n제곱), 공간복잡도는 O(1)이다. 하지만 O(n제곱)의 형태는 출제자가 원하는 방향이 아닐 확률이 높으므로 다시한번 생각해보는게 좋다.  
Arrays.sort를 사용하여 정렬을 한다면 구지 반복문을 2번할 필요없이 현재인덱스 값과 다음인덱스 값만 검색해도 답이 명확해진다. 반복문을 2번하는것보다 Arrays.sort를 사용하는것이 시간복잡도에서 이득이니 정렬한 뒤에 문제를 풀자  
또 다른 방법으로는 set을 사용하는것이 있는데 set은 중복을 허용하지 않고 시간복잡도가 O(1)이다.
