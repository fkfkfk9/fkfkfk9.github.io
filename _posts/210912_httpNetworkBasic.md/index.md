---
title: 그림으로 배우는 Http & Network Basic
date: 2021-09-12 23:13:33
tags: [책 리뷰, network]
---

![책표지](https://bookthumb-phinf.pstatic.net/cover/086/578/08657832.jpg?type=m140&udate=20171016)

[책 정보](https://book.naver.com/bookdb/book_detail.nhn?bid=8657832)

## 그림으로 배우는 Http & Network Basic

---

### 책 소개

> 근 1년간 서버 셋팅을 하기도 하고 3년 넘게 웹개발을 하고있는데 네트워크에 대해 이론적으로 너무 모르고 있고 Http같은 경우 꼭 알아야 함에도 최소한의 정보 말고는 잘 모른다는것에 최근 부끄러움을 느낄때가 있었다.  
> 유튜브에서 추천하는 분들이 있었고 책 후기에도 책에대한 칭찬이 많아 바로 구매하게 되었다. 네트워크 관련 내용들은 학교에서도 자격증을 취득하기 위해서도 공부했지만 항상 너무 어려웠는데 그림으로 얼마나 쉽게 설명해줄지 기대된다.

---

### 1. 웹과 네트워크에 대한 기본

#### HTTP

우리가 URL을 입력하면 해당 URL에 대한 화면이 출력된다. 이처럼 우리는 브라우저(클라이언트)를 통해 서버에 요청을 보내고 서버는 그에대한 응답을 해주는데 이런 클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것이 웹 HTTP라는 프로토콜이다.  
프로토콜이란 약속을 의미하고 웹은 HTTP라는 약속을 사용한 통신으로 이루어져 있습니다.  
최초의 인터넷은 자료를 보내기위해 하이퍼텍스트에 의해 상호간에 참조할 수 있는 WWW의 기본개념의 시스템이었다. WWW를 구성하는 기술은 문서기술로 HTML, 문서 전송 프로토콜로 HTTP, 문소의 주소를 지정하는 방법으로 URL 등이 제안되었다.
HTTP/1.1은 1997년 1월에 공개되었고 현재 가장 많이 사용되는 버전이다. 이 당시에 주로 텍스트를 전송하기 위한 프로토콜이었지만 프로토콜 자체가 심플해서 여러 가지 응용 방법을 고려해 기능이 계속해서 추가되었다.

#### TCP/UDP

인터넷을 포함하여 일반적인 인터넷은 TCP/UDP라는 프로토콜에서 움직이고 있기 때문에 HTTP를 이해하기전에 TCP/UDP 프로토콜에 대한 이해를 해야한다.  
클라이언트와 서버가 통신을 하기 위해선 서로 같은 방식으로 통신해야 하는데 통신 상대를 찾는 방법, 언떤 언어를 사용할건지 통신을 시작하는 방법과 종료하는 방법 같은 규칙들을 결정해야한다. 이렇게 서로 통신을 하기 위한 규칙들을 프로토콜이라 부른다.  
인터넷과 관련된 프로토콜들은 TCP/IP라 부른다.  
TCP/IP에서 중요한 개념은 계증인데 애플리케이션 계층, 트랜스포트 계층, 네트워크 계층, 링크 계층 4가지의 계층으로 나뉜다.

- 애플리케이션 계층 : 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정한다. TCP/IP에는 여러가지의 공통 애플리케이션이 있는데 FTP나 DNS도 포함되고 HTTP또한 이계층에 포함된다.
- 트랜스 포트 계층 : 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공한다. 트랜스포트 계층에는 서로다른 성질을 가진 TCP, UDP가 존재한다.
- 네트워크 계층 : 네트워크 상에서 패킷의 이동을 다룬다. 패킷은 전송하는 데이터의 최소단위를 의미한다. 상대방의 컴퓨터까지 도달하는 동안에 여러 네트워크 장치를 거치게 되는데 이런것을 설정해주는 계층이다.
- 링크 계층 : 네트워크에 접속하는 하드웨어적인 면을 다룬다.

```
통신의 흐름
HTTP 클라이언트 -> TCP -> IP -> 네트워크 -> 네트워크 -> IP -> TCP -> HTTP 서버
이런 과정속에 스택처럼 TCP에는 TCP헤더가 IP에는 IP헤더, 네트워크에는 이더넷 헤더가 붙고 서버에서는 반대로 사용된 헤더를 계층을 지나갈때마다 삭제한다. 이렇게 정보를 감싼는 것을 캡슐화라고 한다.
```

- ip : 네트워크 계층에 해당하고 인터넷을 활용하는 대부분의 시스템이 IP를 이용하고 있다. IP는 프로토콜 명이지 IP주소와는 다르다. IP의 역할은 개별적인 패킷을 상대방에게 전달하는 것이다. 이렇게 상대방에게 전달하려면 여러 가지 정보가 필요한데 그 중 IP주소와 MAC주소가 가장 중요하다. IP주소는 각 노드에 주여된 주소를 가르키고 MAC 주소는 각 네트워크 카드에 할당된 고유 주소이다. IP주소는 변경이 가능하지만 MAC주소는 변경이 불가능하다. 송신할 떄 수신할 IP주소를 설정해준다면 이후 ARP프로토콜이 다음 경로의 MAC주소(라우터)를 찾아주고 해당 네트워크 장비로 이동해가면서 수신할 IP주소로 찾아간다. 결국 IP통신은 처음부터 전송할 경로를 알고 있는것이 아니라 대략적인 목적지만 알고 여러 네트워크 장비들을 거쳐 찾아가게 되는데 이런 과정을 라우팅이라고 한다.
- TCP : 트랜스포트 계층에 해당한다. 특징으로는 신뢰성 있는 바이트 스트림 서비스를 제공하여 대용량의 데이터를 보내기 쉽게 작은 단위의 패킷으로 분해하여 상대방에게 보내고 정확하게 도착했는지 확인하는 역할을 하고있다. 데이터를 보내주는지 확인하는 과정을 쓰레웨이 핸드셰이킹이라 하는데 SYN, SYN/ACK, ACK 플래그들을 통해 확인하기 때문이다. 이 과정중에 통신이 끊긴다면 재전송한다.
- DNS : HTTP와 같은 응용 계층 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다. DNS는 도메인명을 IP주소로 조사하거나 IP 주소로 부터 도메인명을 도사하는 역할을 한다.

#### URL과 URI

우리가 일반적으로 브라우저에서 입력하는 사이트 주소가 URL이다.  
URI의 경우 Uniform Resource Identifiers의 약자이다.

- Uniform : 통일된 서식을 결정하는 것, 여러 가지 종류의 리소스 지정 방법을 같은 맥락에서 구별없이 취급할 수 있게 한다.
- Resource : 리소스는 식별 가능한 모든 것을 의미한다. 도큐먼트 파일뿐 아니라 이미지와 서비스 등 다른 것과 구별할 수 있는 것은 리소스이다.
- Identifier : 식별 가능한 것을 참조하는 오브젝트이며 식별자로 불립니다. 결국, URI는 스키마를 나타내는 리소스를 식별하기 위한 식별자 입니다.

HTTP의 경우에는 `http`를 사용한다. 그 외에도 ftp, mailto, telnet, file 등이 있다.  
URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해 URL은 리소스의 장소(네트워크 상의 위치)를 나타내고 URL은 URI의 서브넷이다.

> URL포맷
>
> - http:와 https:같은 스키마를 사용하여 리소스를 얻기 위해 사용하는 프로토콜을 지시한다.
> - id:pw를 입력하여 자격정보를 입력할수도 있는데 이것은 옵션이고 실제로 사용해본적이 없다.
> - 완전 수식 형식인 URI에서는 서버 주소를 지정할 필요가 있다. DNS이름 또는 IP주소를 입력해준다.
> - 서버주소를 입력하였다면 뒤에 :를 입력한 후 포트를 입력할 수 있다. 이는 접속 대상이 되는 네트워크 포트 번호를 지정한다. 이것은 옵션으로 생략하면 보통 80포트가 동작한다.
> - 파일의 경로 또는 서버의 컨트롤러에서 동작하는 매핑주소가 입력된다.
> - 쿼리 문자열이 추가 되기도 하는데 `?변수명=값`의 형태로 추가해주면 GET방식으로 데이터를 전송할 수 있다.
> - 서브 리소스를 가리키기 위한 프래그먼트 식별자를 사용할 수 있는데 이는 옵션이다.

---

### 2. 간단한 프로토콜 HTTP

HTTP는 클라이언트와 서버간의 통신을 한다. HTTP는 클라이언트에서 서버로 리퀘스트를 보내면 그 결과를 서버는 리스폰스 해준다.

- 리퀘스트 : 서버에 요구하는 종류를 요구하는 메서드(GET,POST)가 포함되고 리소스의 위치인 URI가 포함된다. 또 HTTP의 버전이 포함되며 리퀘스트 헤더 필드와 엔티티가 포함된다.
- 리스폰스 : 리스폰스 또한 HTTP의 버전을 포함하고 있고 해당 요청에 대한 처리결과를 상태 코드와 상태코드에 대한 설명을 포함하고 있다. 또 리스폰스 헤더 필드와 바디로 구성되어있다.

HTTP는 상태를 저장하지 않기 때문에 사용자의 로그인 정보 같은것은 페이지마다 저장하여 넘길 수 없다. 때문에 세션이나 쿠키를 사용하여 정보를 저장해준다.

#### HTTP 메서드

- GET : GET 메서드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구합니다. 개발에서 GET은 전송될 데이터가 노출되는 단점이 있지만 URI에 붙여서 보내는 편리함이 있어 노출해도 되는 데이터를 전송한다면 사용된다.
- POST : POST 메서드는 엔티티를 전송하기 위해서 사용된다. 주로 회원가입, 로그인 같이 보호되야할 데이터가 있을 경우 사용된다.
- PUT : PUT 메서드는 파일을 전송하기 위해 사용된다. 다만 PUT 자체에 인증 기능이 없어 누구든지 업로드가 가능하다는 보안 상의 문제가 있어 일반적으로 사용되지 않는다.
- HEAD : HEAD 메서드는 GET과 같은 기능을 가지고 있지만 메시지 바디는 돌려주지 않는다. URI의 유효성이나 리소스의 갱신 시간을 체크하는 용도로 사용된다.
- DELETE : DELETE메서드는 파일을 삭제하기 위해 사용된다. PUT과 같은 이유로 일반적으로는 사용되지 않으나 REST와 같이 사용되기도 한다.
- OPTION : OPTIONS 메서드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메서드를 조사하기 위해 사용된다.
- TRACE : TRACE 메서드는 웹서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킨다. 이것은 프록시 등을 중계하여 오리진 서버에 접속할 때 그 동작을 확인하기 위해서 사용되는데 거의 사용되지 않는다.
- CONNECT : TCP 통신을 터널링 시키기 위해서 사용된다. 주로 SSL이랑 TLS 등의 프로토콜로 암호화된 것을 터널링 시키기 위해서 사용된다.

#### HTTP의 지속적 연결

초기 HTTP는 접속할 때마다 TCP연결을 하였다. 이는 초창기에 HTTP로 주고받는게 대부분 텍스트였기 때문인데 웹이 발전함에 따라 이미지들이 다수 포함되면서 쓸대없이 통신량이 늘어나기 시작했다.  
이런 문제를 해결하기 위해 HTTP 1.0버전 이후 지속연결을 지원하여 한쪽에서 연결을 종료시키지 않는 이상 TCP연결을 지속시키도록 변경되었다. 지속연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 하여 리스폰스가 끝나지 않아도 리퀘스트를 여러번 보낼 수 있도록 할 수 있다.  
지속연결이 가능하다고 해도 이전 연결에 대한 정보는 가져올 수 없어 매번 다시 접속해주어야 하는데 이를 해결하기 위해 쿠키를 사용할 수 있다. 쿠키는 클라이언트쪽에 저장되어 리퀘스트에 기존의 정보를 보내준다.

### 3. HTTP 정보는 HTTP 메시지에 있다.

HTTP에서 교환하는 정보를 HTTP 메시지라고 부른다. 리퀘스트시에는 리퀘스트 메시지 리스폰스 할때는 리스폰스 메시지이다.  
HTTP 메시지는 복수 행의 데이터로 구성된 텍스트 문자열이다. 또 메시지는 메시지 헤더와 메시지 바디로 구성되어있다. 처음으로 나오는 개행문자(CR+LF)로 둘을 구분할 수 있다.

> - 메시지 헤더 : 서버와 클라이언트가 꼭 처리해야 하는 리퀘스트와 리스폰스 내용과 속성
> - 메시지 바디 : 꼭 전송되는 데이터 그 자체

#### 메시지 헤더 구조

1. 리퀘스트 라인(리퀘스트) : 리퀘스트에 사용하는 메서드와 리퀘스트 URI와 사용하는 HTTP버전이 포함
2. 상태 라인(리스폰스) : 리스폰스 결과를 나타내는 상태코드와 상태코드에 대한 설명, HTTP 버전이 포함
3. 헤더필드 : 리퀘스트와 리스폰스의 여러 조건과 속성등을 나타내는 각종 헤더 필드 포함(일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더 필드, 엔티티 헤더 필드)

#### 인코딩

HTTP로 데이터를 전송할 경우 그대로 전송하는것도 가능하지만 인코딩을 함으로써 효율을 높일 수 있다.

- 메시지 : HTTP 통신의 기본 단위로 옥텟 시퀀스로 구성되고 통신을 통해서 전송된다.
- 엔티티 : 리퀘스트랑 리스폰스의 페이로드로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다.

HTTP 메시지 바디의 역할은 리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반하는 일인데 기본적으로 메시디 바디와 엔티티 바디가 같지만 전송 코딩이 적용되면 엔티티 바디의 내용이 변화한다.

- 콘텐츠 코딩 : 엔티티에 적용하는 인코딩을 가리킨다. 엔티티 정보를 유지한 채로 압축
- 청크 전송 코딩 : 사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표시할 수 있는데 이런 엔티티 바디를 분할하는 기능을 청크 전송 코딩이라고 부른다.

#### 여러 데이터를 보내는 멀티파트

HTTP는 멀티파트에 대응하고 있어 하나의 메시디 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다. 주로 이미지나 문서 등을 업로드할 때 사용되고 있다.

- mulitpart/form-datya : Web form으로부터 파일 업로드에 사용된다.
- multipart/byteranges : 상태 코드 206 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용된다.

### 4. HTTP 상태 코드

> 상태 코드 클래스
>
> - 1xx(Informational) : 리퀘스트를 받아들여 처리 중
> - 2xx(Success) : 리퀘스트를 정상적으로 처리
> - 3xx(Redirection) : 리퀘스트를 완료 하기 위한 추가 작업 필요.
> - 4xx(Client Error) : 서버는 리퀘스트 이해 불가
> - 5xx(Server Error) : 서버는 리퀘스트 처리 실패

- 200 : 성공
- 204 : 성공했으나 해당 리소스가 없는 상태
- 206 : 범위가 지정된 리퀘스트에 일부만 반환
- 301 : 해당 리소스에 새로운 URI가 부여되어 URI를 업데이트하라는 코드
- 302 : 301과 같지만 해당 리소스가 임시로 이동한 상태
- 303 : 302와 같지만 GET 메소드를 얻어야한다고 명시해줌
- 304 : 리소스에 대한 엑세스는 허락하지만 조건이 충족되지 않음
- 307 : 302와 같지만 POST에서 GET으로 치환하지 않는다.
- 400 : 리퀘스트 구문 에러
